import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.database.connection import Base
from app.models.novel import Project, Chapter, Scene

class TestNovelModelIntegration:
    """Integration tests for novel models with actual database"""
    
    @pytest.fixture
    def db_session(self):
        """Create a clean database session for each test"""
        # Use in-memory SQLite database
        engine = create_engine('sqlite:///:memory:')
        Base.metadata.create_all(engine)
        Session = sessionmaker(bind=engine)
        session = Session()
        
        yield session
        
        session.close()
        engine.dispose()
    
    def test_default_values_after_persistence(self, db_session):
        """Test that default values are applied when objects are persisted"""
        project = Project(
            title="Default Test Project",
            author="Test Author"
        )
        
        # Before persistence, defaults are None
        assert project.target_word_count is None
        assert project.current_word_count is None
        assert project.is_active is None
        
        # After persistence, defaults should be applied
        db_session.add(project)
        db_session.commit()
        
        # Refresh the object to get database-applied defaults
        db_session.refresh(project)
        
        assert project.target_word_count == 80000
        assert project.current_word_count == 0
        assert project.is_active is True
    
    def test_project_persistence(self, db_session):
        """Test that Project can be persisted and retrieved"""
        # Create and save a project
        project = Project(
            title="Persisted Novel",
            author="Test Author",
            genre="Mystery",
            target_word_count=60000
        )
        
        db_session.add(project)
        db_session.commit()
        
        # Verify the project was saved with an ID
        assert project.id is not None
        
        # Retrieve the project and verify data
        retrieved_project = db_session.query(Project).filter_by(title="Persisted Novel").first()
        assert retrieved_project.title == "Persisted Novel"
        assert retrieved_project.author == "Test Author"
        assert retrieved_project.genre == "Mystery"
        assert retrieved_project.target_word_count == 60000
    
    def test_chapter_persistence(self, db_session):
        """Test that Chapter can be persisted with Project relationship"""
        # Create project and chapter
        project = Project(title="Novel with Chapters")
        chapter = Chapter(title="First Chapter", order_index=1)
        
        # Establish relationship
        project.chapters.append(chapter)
        
        db_session.add(project)
        db_session.commit()
        
        # Verify both were saved with IDs
        assert project.id is not None
        assert chapter.id is not None
        assert chapter.project_id == project.id
        
        # Verify relationship is intact
        retrieved_project = db_session.query(Project).filter_by(title="Novel with Chapters").first()
        assert len(retrieved_project.chapters) == 1
        assert retrieved_project.chapters[0].title == "First Chapter"
    
    def test_scene_persistence(self, db_session):
        """Test that Scene can be persisted with Chapter relationship"""
        # Create project, chapter, and scene
        project = Project(title="Novel with Scenes")
        chapter = Chapter(title="Chapter 1", order_index=1)
        scene = Scene(title="Opening Scene", order_index=1, content="Scene content...")
        
        # Build relationship chain
        project.chapters.append(chapter)
        chapter.scenes.append(scene)
        
        db_session.add(project)
        db_session.commit()
        
        # Verify all were saved
        assert project.id is not None
        assert chapter.id is not None
        assert scene.id is not None
        assert scene.chapter_id == chapter.id
        
        # Verify relationship chain is intact
        retrieved_project = db_session.query(Project).filter_by(title="Novel with Scenes").first()
        assert len(retrieved_project.chapters) == 1
        assert len(retrieved_project.chapters[0].scenes) == 1
        assert retrieved_project.chapters[0].scenes[0].content == "Scene content..."
    
    def test_cascade_delete_project(self, db_session):
        """Test that deleting a project cascades to chapters and scenes"""
        # Create a project with chapters and scenes
        project = Project(title="Project to Delete")
        chapter = Chapter(title="Chapter 1", order_index=1)
        scene = Scene(title="Scene 1", order_index=1)
        
        project.chapters.append(chapter)
        chapter.scenes.append(scene)
        
        db_session.add(project)
        db_session.commit()
        
        # Store IDs for verification
        project_id = project.id
        chapter_id = chapter.id
        scene_id = scene.id
        
        # Delete the project
        db_session.delete(project)
        db_session.commit()
        
        # Verify everything was deleted
        assert db_session.query(Project).filter_by(id=project_id).first() is None
        assert db_session.query(Chapter).filter_by(id=chapter_id).first() is None
        assert db_session.query(Scene).filter_by(id=scene_id).first() is None
    
    def test_timestamp_automation(self, db_session):
        """Test that created_at and updated_at timestamps are automated"""
        project = Project(title="Timed Project")
        
        db_session.add(project)
        db_session.commit()
        
        # Verify timestamps were set
        assert project.created_at is not None
        assert project.updated_at is not None
        assert project.created_at == project.updated_at
        
        # Update and verify updated_at changes
        original_updated = project.updated_at
        project.title = "Updated Timed Project"
        db_session.commit()
        
        assert project.updated_at > original_updated
    
    def test_order_index_functionality(self, db_session):
        """Test that order_index works for sorting"""
        project = Project(title="Ordered Project")
        
        # Create chapters in reverse order
        chapter3 = Chapter(title="Chapter 3", order_index=3)
        chapter1 = Chapter(title="Chapter 1", order_index=1)
        chapter2 = Chapter(title="Chapter 2", order_index=2)
        
        project.chapters.extend([chapter3, chapter1, chapter2])
        db_session.add(project)
        db_session.commit()
        
        # Verify chapters are ordered by order_index
        retrieved_project = db_session.query(Project).filter_by(title="Ordered Project").first()
        chapter_titles = [chapter.title for chapter in retrieved_project.chapters]
        assert chapter_titles == ["Chapter 1", "Chapter 2", "Chapter 3"]